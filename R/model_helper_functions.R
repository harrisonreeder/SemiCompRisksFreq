

####HELPER FUNCTIONS FOR QUADRATURE####

#' Function to return quadrature points and weights
#'
#' This function stores quadrature points used for numerical integration by either
#' Gauss-Kronrod or Gauss-Legendre rules. The values are pre-computed and stored for
#' number of nodes equal to 7, 11, 15, 21, 31, 41, 51, or 61.
#'
#' @inheritParams FreqID_HReg2
#' @return A list with two named elements (\code{points} and \code{weights}), each
#'   of which is a numeric vector with length equal to the number of
#'   quadrature nodes
get_quad_pointsweights <- function(n_quad, quad_method) {
  if (!is.numeric(n_quad) || (length(n_quad) > 1L)) {
    stop("'n_quad' should be a numeric vector of length 1.")
  }

  if(tolower(quad_method)=="kronrod"){ #calculated using: https://keisan.casio.com/exec/system/1289382036
    if (n_quad == 61) {
      list( points = c(
        -0.9994844100504906375713, -0.9968934840746495402716, -0.9916309968704045948586,
        -0.98366812327974720997, -0.9731163225011262683747, -0.9600218649683075122169,
        -0.944374444748559979416, -0.9262000474292743258793, -0.9055733076999077985465,
        -0.8825605357920526815431, -0.8572052335460610989587, -0.8295657623827683974429,
        -0.7997278358218390830137, -0.767777432104826194918, -0.733790062453226804726,
        -0.697850494793315796932, -0.6600610641266269613701, -0.6205261829892428611405,
        -0.579345235826361691756, -0.5366241481420198992642, -0.4924804678617785749937,
        -0.4470337695380891767806, -0.4004012548303943925355, -0.352704725530878113471,
        -0.3040732022736250773727, -0.2546369261678898464398, -0.204525116682309891439,
        -0.1538699136085835469638, -0.1028069379667370301471, -0.05147184255531769583303,
        0, 0.051471842555317695833, 0.1028069379667370301471, 0.1538699136085835469638,
        0.204525116682309891439, 0.25463692616788984644, 0.304073202273625077373,
        0.352704725530878113471, 0.4004012548303943925355, 0.4470337695380891767806,
        0.4924804678617785749937, 0.5366241481420198992642, 0.579345235826361691756,
        0.6205261829892428611405, 0.6600610641266269613701, 0.6978504947933157969323,
        0.7337900624532268047262, 0.767777432104826194918, 0.7997278358218390830137,
        0.8295657623827683974429, 0.8572052335460610989587, 0.8825605357920526815431,
        0.9055733076999077985465, 0.9262000474292743258793, 0.9443744447485599794158,
        0.9600218649683075122169, 0.9731163225011262683747, 0.98366812327974720997,
        0.9916309968704045948586, 0.9968934840746495402716, 0.9994844100504906375713),
        weights = c(
          0.0013890136986770076246, 0.0038904611270998840513, 0.0066307039159312921733,
          0.0092732796595177634284, 0.0118230152534963417422, 0.0143697295070458048125,
          0.0169208891890532726276, 0.0194141411939423811734, 0.021828035821609192297,
          0.02419116207808060136569, 0.0265099548823331016106, 0.028754048765041292844,
          0.0309072575623877624729, 0.0329814470574837260318, 0.0349793380280600241375,
          0.0368823646518212292239, 0.0386789456247275929503, 0.040374538951535959112,
          0.04196981021516424614715, 0.043452539701356069317, 0.0448148001331626631924,
          0.04605923827100698811627, 0.047185546569299153945, 0.048185861757087129141,
          0.04905543455502977888753, 0.0497956834270742063578, 0.050405921402782346841,
          0.0508817958987496064923, 0.051221547849258772171, 0.0514261285374590259339,
          0.0514947294294515675583, 0.0514261285374590259339, 0.0512215478492587721707,
          0.050881795898749606492, 0.0504059214027823468409, 0.0497956834270742063578,
          0.049055434555029778888, 0.0481858617570871291408, 0.0471855465692991539453,
          0.0460592382710069881163, 0.044814800133162663192, 0.0434525397013560693168,
          0.041969810215164246147, 0.040374538951535959112, 0.03867894562472759295,
          0.0368823646518212292239, 0.0349793380280600241375, 0.032981447057483726032,
          0.030907257562387762473, 0.028754048765041292844, 0.0265099548823331016106,
          0.0241911620780806013657, 0.021828035821609192297, 0.0194141411939423811734,
          0.0169208891890532726276, 0.0143697295070458048125, 0.011823015253496341742,
          0.0092732796595177634284, 0.0066307039159312921733, 0.003890461127099884051,
          0.0013890136986770076246
        ))
    } else if (n_quad == 51) {
      list( points = c(
        -0.999262104992609834193, -0.995556969790498097909, -0.9880357945340772476373,
        -0.976663921459517511498, -0.9616149864258425124181, -0.942974571228974339414,
        -0.9207471152817015617464, -0.894991997878275368851, -0.865847065293275595449,
        -0.833442628760834001421, -0.7978737979985000594104, -0.7592592630373576305773,
        -0.7177664068130843881867, -0.6735663684734683644851, -0.6268100990103174127881,
        -0.5776629302412229677237, -0.5263252843347191825996, -0.4730027314457149605222,
        -0.4178853821930377488518, -0.3611723058093878377358, -0.3030895389311078301675,
        -0.2438668837209884320452, -0.183718939421048892016, -0.1228646926107103963874,
        -0.0615444830056850788865, 0, 0.06154448300568507888655, 0.1228646926107103963874,
        0.183718939421048892016, 0.2438668837209884320452, 0.3030895389311078301675,
        0.361172305809387837736, 0.4178853821930377488518, 0.4730027314457149605222,
        0.5263252843347191825996, 0.5776629302412229677237, 0.6268100990103174127881,
        0.673566368473468364485, 0.7177664068130843881867, 0.7592592630373576305773,
        0.7978737979985000594104, 0.833442628760834001421, 0.865847065293275595449,
        0.894991997878275368851, 0.9207471152817015617464, 0.942974571228974339414,
        0.9616149864258425124181, 0.9766639214595175114983, 0.9880357945340772476373,
        0.9955569697904980979088, 0.9992621049926098341935),
      weights = c(
        0.001987383892330315927, 0.005561932135356713758, 0.0094739733861741516072,
        0.0132362291955716748137, 0.0168478177091282982315, 0.0204353711458828354566,
        0.0240099456069532162201, 0.0274753175878517378029, 0.0307923001673874888911,
        0.0340021302743293378367, 0.0371162714834155435603, 0.0400838255040323820748,
        0.0428728450201700494769, 0.04550291304992178891, 0.047982537138836713906,
        0.05027767908071567196333, 0.0523628858064074758644, 0.05425112988854549014454,
        0.055950811220412317308, 0.0574371163615678328536, 0.058689680022394207962,
        0.0597203403241740599791, 0.0605394553760458629454, 0.0611285097170530483059,
        0.0614711898714253166615, 0.0615808180678329350788, 0.0614711898714253166615,
        0.06112850971705304830586, 0.0605394553760458629454, 0.0597203403241740599791,
        0.058689680022394207962, 0.0574371163615678328536, 0.0559508112204123173082,
        0.0542511298885454901445, 0.05236288580640747586437, 0.0502776790807156719633,
        0.047982537138836713906, 0.04550291304992178891, 0.042872845020170049477,
        0.0400838255040323820748, 0.0371162714834155435603, 0.034002130274329337837,
        0.030792300167387488891, 0.02747531758785173780295, 0.0240099456069532162201,
        0.02043537114588283545657, 0.0168478177091282982315, 0.0132362291955716748137,
        0.0094739733861741516072, 0.00556193213535671375804, 0.001987383892330315926508))
    } else if (n_quad == 41) {
      list( points = c(
         -0.9988590315882776638383, -0.9931285991850949247861, -0.9815078774502502591933,
         -0.9639719272779137912677, -0.94082263383175475352, -0.9122344282513259058678,
         -0.8782768112522819760774, -0.8391169718222188233945, -0.7950414288375511983506,
         -0.7463319064601507926143, -0.693237656334751384805, -0.6360536807265150254528,
         -0.575140446819710315343, -0.5108670019508270980044, -0.4435931752387251032,
         -0.3737060887154195606725, -0.3016278681149130043206, -0.2277858511416450780805,
         -0.152605465240922675505, -0.0765265211334973337546, 0, 0.07652652113349733375464,
         0.1526054652409226755052, 0.22778585114164507808, 0.3016278681149130043206,
         0.3737060887154195606725, 0.4435931752387251032, 0.5108670019508270980044,
         0.575140446819710315343, 0.6360536807265150254528, 0.6932376563347513848055,
         0.7463319064601507926143, 0.7950414288375511983506, 0.8391169718222188233945,
         0.8782768112522819760774, 0.912234428251325905868, 0.94082263383175475352,
         0.9639719272779137912677, 0.9815078774502502591933, 0.9931285991850949247861,
         0.9988590315882776638383),
        weights = c(
          0.00307358371852053150122, 0.0086002698556429421987, 0.0146261692569712529838,
          0.020388373461266523598, 0.02588213360495115883451, 0.0312873067770327989585,
          0.0366001697582007980306, 0.0416688733279736862638, 0.04643482186749767472023,
          0.0509445739237286919327, 0.0551951053482859947448, 0.059111400880639572375,
          0.06265323755478116802587, 0.0658345971336184221116, 0.0686486729285216193456,
          0.071054423553444068306, 0.073030690332786667495, 0.0745828754004991889866,
          0.0757044976845566746595, 0.076377867672080736706, 0.07660071191799965644505,
          0.0763778676720807367055, 0.07570449768455667466, 0.074582875400499188987,
          0.073030690332786667495, 0.071054423553444068306, 0.068648672928521619346,
          0.065834597133618422112, 0.0626532375547811680259, 0.059111400880639572375,
          0.055195105348285994745, 0.050944573923728691933, 0.04643482186749767472,
          0.0416688733279736862638, 0.0366001697582007980306, 0.031287306777032798959,
          0.0258821336049511588345, 0.020388373461266523598, 0.0146261692569712529838,
          0.0086002698556429421987, 0.00307358371852053150122))
    } else if (n_quad == 31) {
      list( points = c(
         -0.9980022986933970602852, -0.9879925180204854284896, -0.9677390756791391342574,
         -0.9372733924007059043078, -0.8972645323440819008825, -0.8482065834104272162007,
         -0.7904185014424659329677, -0.724417731360170047416, -0.6509967412974169705337,
         -0.5709721726085388475372, -0.4850818636402396806937, -0.3941513470775633698972,
         -0.2991800071531688121668, -0.2011940939974345223006, -0.1011420669187174990271,
         0, 0.1011420669187174990271, 0.2011940939974345223006, 0.2991800071531688121668,
         0.3941513470775633698972, 0.4850818636402396806937, 0.5709721726085388475372,
         0.6509967412974169705337, 0.7244177313601700474162, 0.7904185014424659329677,
         0.8482065834104272162007, 0.8972645323440819008825, 0.9372733924007059043078,
         0.9677390756791391342574, 0.9879925180204854284896, 0.9980022986933970602852),
        weights = c(
          0.0053774798729233489878, 0.0150079473293161225384, 0.025460847326715320187,
          0.035346360791375846222, 0.044589751324764876608, 0.0534815246909280872653,
          0.0620095678006706402851, 0.06985412131872825871, 0.0768496807577203788944,
          0.0830805028231330210383, 0.0885644430562117706473, 0.0931265981708253212255,
          0.0966427269836236785052, 0.0991735987217919593324, 0.100769845523875595045,
          0.101330007014791549017, 0.100769845523875595045, 0.0991735987217919593324,
          0.096642726983623678505, 0.093126598170825321225, 0.088564443056211770647,
          0.083080502823133021038, 0.0768496807577203788944, 0.0698541213187282587095,
          0.062009567800670640285, 0.0534815246909280872653, 0.044589751324764876608,
          0.035346360791375846222, 0.0254608473267153201869, 0.015007947329316122538,
          0.0053774798729233489878))
    } else if (n_quad == 21) {
      list(points = c(
        -0.9956571630258080807355, -0.973906528517171720078, -0.9301574913557082260012,
        -0.8650633666889845107321, -0.7808177265864168970637, -0.6794095682990244062343,
        -0.562757134668604683339, -0.4333953941292471907993, -0.294392862701460198131,
        -0.1488743389816312108848, 0, 0.1488743389816312108848, 0.2943928627014601981311,
        0.4333953941292471907993, 0.562757134668604683339, 0.6794095682990244062343,
        0.7808177265864168970637, 0.865063366688984510732, 0.9301574913557082260012,
        0.973906528517171720078, 0.9956571630258080807355),
        weights = c(
          0.0116946388673718742781, 0.0325581623079647274788, 0.0547558965743519960314,
          0.075039674810919952767, 0.093125454583697605535, 0.1093871588022976418992,
          0.123491976262065851078, 0.134709217311473325928, 0.142775938577060080797,
          0.1477391049013384913748, 0.149445554002916905665, 0.1477391049013384913748,
          0.1427759385770600807971, 0.134709217311473325928, 0.123491976262065851078,
          0.109387158802297641899, 0.093125454583697605535, 0.075039674810919952767,
          0.05475589657435199603138, 0.032558162307964727479, 0.0116946388673718742781))
    } else if (n_quad == 15) {
      list( points = c(
          -0.991455371120812639207,-0.949107912342758524526,-0.86486442335976907279,
          -0.7415311855993944398639,-0.5860872354676911302941,-0.4058451513773971669066,
          -0.2077849550078984676007,0,0.2077849550078984676007,
          0.405845151377397166907,0.5860872354676911302941,0.741531185599394439864,
          0.86486442335976907279,0.9491079123427585245262,0.991455371120812639207),
        weights = c(
          0.0229353220105292249637,0.063092092629978553291,0.10479001032225018384,
          0.140653259715525918745,0.1690047266392679028266,0.1903505780647854099133,
          0.204432940075298892414,0.209482141084727828013,0.204432940075298892414,
          0.1903505780647854099133,0.169004726639267902827,0.140653259715525918745,
          0.1047900103222501838399,0.063092092629978553291,0.0229353220105292249637))
    } else if (n_quad == 11) {
      list( points = c(
          -0.984085360094842464496,-0.906179845938663992798,-0.754166726570849220441,
          -0.5384693101056830910363,-0.2796304131617831934135,0,
          0.2796304131617831934135,0.5384693101056830910363,0.754166726570849220441,
          0.906179845938663992798,0.984085360094842464496),
        weights = c(
          0.042582036751081832865,0.1152333166224733940246,0.186800796556492657468,
          0.2410403392286475866999,0.272849801912558922341,0.2829874178574912132043,
          0.272849801912558922341,0.241040339228647586701,0.186800796556492657467,
          0.115233316622473394025,0.042582036751081832865))
    } else if (n_quad == 7) {
      list( points = c(
          -0.9604912687080202834235,-0.7745966692414833770359,-0.4342437493468025580021,
          0,0.4342437493468025580021,0.7745966692414833770359,0.9604912687080202834235),
        weights = c(
          0.1046562260264672651938,0.268488089868333440729,0.401397414775962222905,
          0.450916538658474142345,0.401397414775962222905,0.268488089868333440729,
          0.104656226026467265194))
    } else stop("'n_quad' must be either 7, 11, 15, 21, 31, 41, 51, or 61.")

  } else if (tolower(quad_method) == "legendre"){ #calculated using: https://keisan.casio.com/exec/system/1280624821
    if (n_quad == 61) {
      list(points = c(
        -0.9992355976313634717319, -0.995974599815120234268, -0.9901167452325170509655,
        -0.9816760112840370796852, -0.9706742588331829082474, -0.9571401519129840913721,
        -0.9411089866813611474775, -0.9226225813829552612576, -0.901729162474001170642,
        -0.878483237214881032479, -0.8529454508476634455649, -0.8251824281086599506643,
        -0.7952665992823596491521, -0.7632760111723121971459, -0.729294123449465109689,
        -0.6934095908944911554992, -0.6557160320950708716992, -0.6163117851979217247096,
        -0.5752996513508306186004, -0.532786626502925265638, -0.4888836222622521188207,
        -0.443705176538531601996, -0.3973691547257566091783, -0.349996442204066834533,
        -0.3017106289630307126045, -0.2526376871690534958337, -0.2029056425180584992269,
        -0.1526442402308153005295, -0.101984606562274068957, -0.0510589067079743493669, 0,
        0.0510589067079743493669, 0.101984606562274068957, 0.15264424023081530053,
        0.2029056425180584992269, 0.2526376871690534958337, 0.3017106289630307126045,
        0.349996442204066834533, 0.3973691547257566091783, 0.4437051765385316019956,
        0.4888836222622521188207, 0.5327866265029252656385, 0.5752996513508306186004,
        0.6163117851979217247096, 0.6557160320950708716992, 0.6934095908944911554992,
        0.729294123449465109689, 0.7632760111723121971459, 0.7952665992823596491521,
        0.8251824281086599506643, 0.8529454508476634455649, 0.878483237214881032479,
        0.901729162474001170642, 0.9226225813829552612576, 0.9411089866813611474775,
        0.9571401519129840913721, 0.9706742588331829082474, 0.9816760112840370796852,
        0.9901167452325170509655, 0.995974599815120234268, 0.9992355976313634717319),
        weights = c(
        0.0019614533616702826718, 0.004560924006012417185, 0.0071523549917490895858,
        0.009725461830356133736, 0.0122732635078121046293, 0.0147890658849379145462,
        0.01726629298761374359443, 0.019698477746101181331, 0.0220792731483190440025,
        0.0244024671875442029153, 0.0266619985241508896628, 0.0288519720881834015043,
        0.030966674368397394825, 0.0330005882759074106327, 0.0349484075165333510909,
        0.0368050504231548173843, 0.0385656732070081727462, 0.040225682590998247368,
        0.0417807477908884920667, 0.043226811812496097901, 0.04456010203508348827154,
        0.045777140053145959371, 0.0468747507508090659764, 0.047850070585095607162,
        0.0487005550564115260875, 0.04942398534673558994, 0.0500184741081782534251,
        0.0504824703867974046481, 0.0508147636688183432077, 0.051014487038697263544,
        0.051081119440786217978, 0.051014487038697263544, 0.050814763668818343208,
        0.050482470386797404648, 0.0500184741081782534251, 0.04942398534673558994,
        0.048700555056411526088, 0.0478500705850956071618, 0.0468747507508090659764,
        0.045777140053145959371, 0.0445601020350834882715, 0.043226811812496097901,
        0.041780747790888492067, 0.040225682590998247368, 0.038565673207008172746,
        0.036805050423154817384, 0.034948407516533351091, 0.0330005882759074106327,
        0.0309666743683973948247, 0.028851972088183401504, 0.0266619985241508896628,
        0.024402467187544202915, 0.0220792731483190440025, 0.019698477746101181331,
        0.0172662929876137435944, 0.01478906588493791454618, 0.0122732635078121046293,
        0.009725461830356133736, 0.0071523549917490895858, 0.004560924006012417185,
        0.0019614533616702826718))
    } else if (n_quad == 51) {
      list(points = c(
        -0.998909990848903495169, -0.9942612604367525746211, -0.9859159917359029965839,
        -0.9739033680193238672318, -0.9582678486139081945577, -0.9390675440029623834354,
        -0.9163738623097802308236, -0.8902712180295273032778, -0.860856711182292371474,
        -0.8282397638230648328548, -0.7925417120993812052344, -0.753895354485375525764,
        -0.7124444575770366445805, -0.6683432211753700868645, -0.621755704600723273755,
        -0.5728552163513038365224, -0.5218236693661858425141, -0.46885090428604106361,
        -0.4141339832263038779369, -0.3578764566884095097752, -0.3002876063353319395302,
        -0.2415816664477987038467, -0.181977026957077545324, -0.1216954210188887669638,
        -0.0609611001505787247342, 0, 0.0609611001505787247342, 0.1216954210188887669638,
        0.181977026957077545324, 0.241581666447798703847, 0.3002876063353319395302,
        0.357876456688409509775, 0.4141339832263038779369, 0.4688509042860410636105,
        0.5218236693661858425141, 0.5728552163513038365224, 0.621755704600723273755,
        0.6683432211753700868645, 0.7124444575770366445805, 0.753895354485375525764,
        0.7925417120993812052344, 0.8282397638230648328548, 0.8608567111822923714735,
        0.8902712180295273032778, 0.9163738623097802308236, 0.9390675440029623834354,
        0.9582678486139081945577, 0.9739033680193238672318, 0.9859159917359029965839,
        0.9942612604367525746211, 0.998909990848903495169),
        weights = c(
        0.0027968071710898955755, 0.0065003377832526002921, 0.0101851912978217299392,
        0.0138326340064778222967, 0.01742871472340105226, 0.0209599884017032105798,
        0.0244133005737814342731, 0.027775798594162477196, 0.0310349712901600084544,
        0.034178693204188336236, 0.037195268923260292843, 0.0400734762854964531868,
        0.0428026079978800866536, 0.0453725114076500687482, 0.047773626240623102,
        0.0499970201500574097795, 0.052034421936697087564, 0.0538782523130455614341,
        0.0555216520957386930167, 0.0569585077202586621001, 0.0581834739825921405984,
        0.0591919939229615437835, 0.0599803157775032520901, 0.0605455069347377951381,
        0.0608854648448563438812, 0.0609989248412058801598, 0.060885464844856343881,
        0.0605455069347377951381, 0.05998031577750325209, 0.0591919939229615437835,
        0.0581834739825921405984, 0.0569585077202586621, 0.05552165209573869301674,
        0.053878252313045561434, 0.052034421936697087564, 0.0499970201500574097795,
        0.047773626240623102, 0.045372511407650068748, 0.0428026079978800866536,
        0.04007347628549645318681, 0.0371952689232602928429, 0.0341786932041883362362,
        0.031034971290160008454, 0.027775798594162477196, 0.0244133005737814342731,
        0.02095998840170321058, 0.0174287147234010522595, 0.013832634006477822297,
        0.01018519129782172993924, 0.006500337783252600292, 0.0027968071710898955755))
    } else if (n_quad == 41) {
      list(points = c(
        -0.9983215885747714415192, -0.9911671096990163082502, -0.9783386735610833844692,
        -0.9599068917303462260994, -0.9359769874978538256823, -0.9066859447581011729583,
        -0.8722015116924414088337, -0.8327212004013613312443, -0.788471145047409372736,
        -0.7397048030699261810602, -0.6867015020349512895846, -0.6297648390721963204887,
        -0.5692209416102158696548, -0.5054165991994060327083, -0.4387172770514070885171,
        -0.3695050226404814414284, -0.298176277341824865923, -0.2251396056334227756058,
        -0.1508133548639921635744, -0.0756232589891629969238, 0, 0.07562325898916299692377,
        0.1508133548639921635744, 0.2251396056334227756058, 0.298176277341824865923,
        0.3695050226404814414284, 0.4387172770514070885171, 0.5054165991994060327083,
        0.5692209416102158696548, 0.6297648390721963204887, 0.6867015020349512895846,
        0.7397048030699261810602, 0.7884711450474093727362, 0.8327212004013613312443,
        0.8722015116924414088337, 0.9066859447581011729583, 0.9359769874978538256823,
        0.9599068917303462260994, 0.9783386735610833844692, 0.9911671096990163082502,
        0.9983215885747714415192),
        weights = c(
        0.004306140358164887684, 0.0099999387739059453385, 0.015644938407818588531,
        0.0212010633687795530757, 0.0266358992071104454675, 0.031918211731699281787,
        0.0370177167035079884353, 0.0419051951959096894293, 0.04655264836901434206076,
        0.0509334542946174947812, 0.0550225192425787418801, 0.0587964209498719449912,
        0.0622335425809663164716, 0.065314196453527410436, 0.0680207367608767667355,
        0.0703376606208174974817, 0.0722516968610230733963, 0.0737518820272234699393,
        0.074829623176221551891, 0.07547874709271582402725, 0.0756955356472983723188,
        0.0754787470927158240272, 0.0748296231762215518913, 0.07375188202722346993928,
        0.072251696861023073396, 0.0703376606208174974817, 0.0680207367608767667355,
        0.0653141964535274104362, 0.0622335425809663164716, 0.058796420949871944991,
        0.0550225192425787418801, 0.0509334542946174947812, 0.0465526483690143420608,
        0.041905195195909689429, 0.0370177167035079884353, 0.0319182117316992817871,
        0.0266358992071104454675, 0.021201063368779553076, 0.0156449384078185885308,
        0.0099999387739059453385, 0.004306140358164887684))
    } else if (n_quad == 31) {
      list(points = c(
        -0.9970874818194770740556, -0.9846859096651524840025, -0.9625039250929496617891,
        -0.930756997896648164957, -0.8897600299482710433742, -0.8399203201462673400869,
        -0.781733148416624940406, -0.715776784586853283906, -0.6427067229242603461844,
        -0.5632491614071492627209, -0.4781937820449024804406, -0.3883859016082329430614,
        -0.2947180699817016166179, -0.1981211993355706287724, -0.0995553121523415203252,
        0, 0.0995553121523415203252, 0.1981211993355706287724, 0.294718069981701616618,
        0.3883859016082329430614, 0.4781937820449024804406, 0.5632491614071492627209,
        0.6427067229242603461844, 0.715776784586853283906, 0.7817331484166249404064,
        0.8399203201462673400869, 0.889760029948271043374, 0.930756997896648164957,
        0.9625039250929496617891, 0.9846859096651524840025, 0.9970874818194770740556),
        weights = c(
        0.0074708315792487758587, 0.0173186207903105824632, 0.0270090191849794218006,
        0.0364322739123854640244, 0.0454937075272011029023, 0.05410308242491685371167,
        0.0621747865610284269103, 0.0696285832354103661678, 0.07639038659877661642636,
        0.08239299176158926390382, 0.0875767406084778761262, 0.091890113893641478215,
        0.0952902429123195128072, 0.0977433353863287250935, 0.0992250112266723078749,
        0.0997205447934264514275, 0.099225011226672307875, 0.0977433353863287250935,
        0.0952902429123195128072, 0.0918901138936414782154, 0.087576740608477876126,
        0.0823929917615892639038, 0.076390386598776616426, 0.0696285832354103661678,
        0.06217478656102842691, 0.0541030824249168537117, 0.0454937075272011029023,
        0.036432273912385464024, 0.0270090191849794218006, 0.017318620790310582463,
        0.007470831579248775859))
    } else if (n_quad == 21) {
      list(points = c(
        -0.9937521706203895002602, -0.9672268385663062943166, -0.9200993341504008287902,
        -0.8533633645833172836473, -0.7684399634756779086159, -0.667138804197412319306,
        -0.551618835887219807059, -0.4243421202074387835737, -0.2880213168024010966008,
        -0.145561854160895090937, 0, 0.145561854160895090937, 0.2880213168024010966008,
        0.4243421202074387835737, 0.551618835887219807059, 0.667138804197412319306,
        0.7684399634756779086159, 0.8533633645833172836473, 0.9200993341504008287902,
        0.9672268385663062943166, 0.9937521706203895002602),
        weights = c(
        0.01601722825777433332423, 0.0369537897708524938, 0.05713442542685720828364,
        0.0761001136283793020171, 0.0934444234560338615533, 0.108797299167148377663,
        0.1218314160537285341954, 0.132268938633337461781, 0.1398873947910731547221,
        0.144524403989970059064, 0.146081133649690427192, 0.1445244039899700590638,
        0.1398873947910731547221, 0.1322689386333374617811, 0.1218314160537285341954,
        0.108797299167148377663, 0.0934444234560338615533, 0.0761001136283793020171,
        0.057134425426857208284, 0.0369537897708524938, 0.016017228257774333324))
    } else if (n_quad == 15) {
      list(points = c(
        -0.9879925180204854284896, -0.9372733924007059043078, -0.8482065834104272162007,
        -0.7244177313601700474162, -0.5709721726085388475372, -0.394151347077563369897,
        -0.2011940939974345223006, 0, 0.2011940939974345223006, 0.394151347077563369897,
        0.5709721726085388475372, 0.7244177313601700474162, 0.8482065834104272162007,
        0.9372733924007059043078, 0.9879925180204854284896),
        weights = c(
        0.03075324199611726835463, 0.0703660474881081247093, 0.107159220467171935012,
        0.1395706779261543144478, 0.1662692058169939335532, 0.186161000015562211027,
        0.198431485327111576456, 0.2025782419255612728806, 0.198431485327111576456,
        0.1861610000155622110268, 0.1662692058169939335532, 0.1395706779261543144478,
        0.1071592204671719350119, 0.070366047488108124709, 0.0307532419961172683546))
    } else if (n_quad == 11) {
      list(points = c(
        -0.9782286581460569928039, -0.8870625997680952990752, -0.7301520055740493240934,
        -0.5190961292068118159257, -0.2695431559523449723315, 0, 0.269543155952344972332,
        0.5190961292068118159257, 0.7301520055740493240934, 0.887062599768095299075,
        0.9782286581460569928039),
        weights = c(
        0.0556685671161736664828, 0.1255803694649046246347, 0.1862902109277342514261,
        0.2331937645919904799185, 0.2628045445102466621807, 0.2729250867779006307145,
        0.262804544510246662181, 0.2331937645919904799185, 0.1862902109277342514261,
        0.1255803694649046246347, 0.055668567116173666483))
    } else if (n_quad == 7) {
      list(points = c(
      -0.9491079123427585245262, -0.7415311855993944398639, -0.4058451513773971669066, 0,
      0.4058451513773971669066, 0.7415311855993944398639, 0.9491079123427585245262),
      weights = c(
      0.1294849661688696932706, 0.2797053914892766679015, 0.38183005050511894495,
      0.417959183673469387755, 0.38183005050511894495, 0.279705391489276667901,
      0.129484966168869693271))
    } else stop("'n_quad' must be either 7, 11, 15, 21, 31, 41, 51, or 61.")
  } else stop("'quad_method' must be either 'kronrod' or 'legendre' ")
}

#' Return transformed Gaussian quadrature points based on the specified integral limits
#'
#' @inheritParams FreqID_HReg2
#' @param a vector lower limit of the integral
#' @param b vector upper limit of the integral
transform_quad_points <- function(n_quad, quad_method, a, b) {
  if (!all(is.numeric(a), is.numeric(b)))
    stop("'a' and 'b' should be numeric.", call. = FALSE)
  if (!length(a) %in% c(1L, length(b)))
    stop("'a' and 'b' should be vectors of length 1, or, be the same length.", call. = FALSE)
  if (any((b - a) < 0))
    stop("The upper limits for the integral ('b' values) should be greater than ",
         "the corresponding lower limits for the integral ('a' values).", call. = FALSE)
  #return a vector where the first _nodes_ are the transformed quadrature points
  #corresponding with the first element of (a,b), then the second block corresponds
  #with the second element of (a,b), etc.
  as.vector(t(sapply(X = get_quad_pointsweights(n_quad = n_quad, quad_method = quad_method)$points,
                     FUN = function(x) ((b - a) / 2) * x + ((b + a) / 2))))
}

####HELPER KNOT AND BASIS FUNCTIONS####

####Univariate####

#' Generate Knot Location Vector from Event Times
#'
#' This function creates a list containing three numeric vectors. Each numeric vector
#'   is a sequence of increasing integers giving the location of knots used for
#'   spline and piecewise baseline hazard specifications. This function
#'   generates this list according to the conventions and recommended locations
#'   of these knots, which depends on the choice of hazard specification, number
#'   of knots requested, and distribution of observed event times.
#'
#'
#' @inheritParams nll_func
#' @param y Numeric vector of length \eqn{n} with (possibly censored) event times
#' @param delta Numeric vector of length \eqn{n}  with indicator of 1 if the event was observed and 0 otherwise
#' @param p0 Integer indicating how many parameters the model for the baseline hazard should specify.
#'
#' @return A vector of increasing sequences of integers, each corresponding to
#'   the knots for the flexible model on the corresponding transition baseline hazard.
#'   For cubic B-splines on log-hazard: min 0, max is max observed value of \code{y},
#'   \code{p0-4} internal knots placed at quantiles of observed events \code{y[delta==1]}.
#'   For Royston-Parmar (restricted cubic spline on log-cumulative hazard): min and max at min and max observed event times,
#'   \code{p0-2} internal knots placed at quantiles of observed events
#'   For piecewise constant: min 0, remaining \code{p0-1} knots placed at quantiles of observed events.
#'
#' @export
get_default_knots <- function(y,delta,p0,hazard){
  if(tolower(hazard) %in% c("bspline","bs")){
    # Recall, cubic bsplines are built by columns that are basically an orthogonalized transformation of:
    # (1, y, y^2, y^3, (y-internalknot1)_+^3,(y-internalknot2)_+^3,(y-internalknot3)_+^3),...
    # Therefore, for cubic spline the minimum number of parameters in a hazard must be 4 (aka no internal knots)
    if(p0 < 4){stop("Cubic B-Spline Specification must have at least 4 parameters in each hazard.")}
    quantile_seq <- seq(from = 0,to = 1, length.out = p0-2)[-c(1,p0-2)]
    knots_temp <- c(0,stats::quantile(y[delta==1],quantile_seq),max(y))
  } else if(tolower(hazard) %in% c("piecewise","pw")){
    quantile_seq <- seq(from = 0,to = 1, length.out = p0+1)[-c(1,p0+1)]
    knots_temp <- c(0,stats::quantile(y[delta==1],quantile_seq))
  } else if(tolower(hazard) %in% c("royston-parmar","rp")){
    #in rp model, boundary knots are set directly at endpoints, so no need to fix at 0
    quantile_seq <- seq(from = 0,to = 1, length.out = p0)
    #rp model puts splines on log scale, but let's specify knots on original scale and
    #transform them in the get_basis function (makes the knots themselves more interpretable and consistent)
    knots_temp <- stats::quantile(y[delta==1],quantile_seq)
  } else {return(NULL)}

  return(knots_temp)
}

#' Get Basis Function Values for Flexible Hazard Specifications
#'
#' Generate a matrix of basis functions evaluated at each value of a vector \code{x}.
#'
#' @inheritParams nll_func
#' @param x Numeric vector of event times (e.g., \code{y1} or \code{y2}) at which
#'   to generate basis function values.
#' @param knots Increasing vector of integers corresponding to the knots used
#'   in the desired spline or piecewise specification. Often an element of
#'   list generated from \code{\link{get_default_knots_list}}.
#' @param deriv Boolean for whether returned values should be from derivatives of
#'   basis functions if \code{TRUE}, or original basis functions if \code{FALSE}.
#'
#' @return A matrix with each row corresponding to an element of the input, and
#'   each column giving the corresponding basis function value.
#'
#' @import splines2
#' @export
get_basis <- function(x,knots,hazard,deriv=FALSE){
  # browser()
  #the exact form of the knots passed into this function come from the above function
  if(tolower(hazard) %in% c("bspline","bs")){
    if(deriv){return(NULL)}
    basis_out <- splines::bs(x = x, knots = knots[-c(1,length(knots))],
                    Boundary.knots = knots[c(1,length(knots))],intercept = TRUE)
  } else if(tolower(hazard) %in% c("piecewise","pw")){
    if(deriv){
      # this is what the actual matrix of piecewise constant basis functions looks like
      basis_out <- splines2::bSpline(x,knots=knots[-1], degree = 0,
                     Boundary.knots = c(knots[1],1e305),intercept = TRUE)
      #To make things more efficient, we could use the "dbasis"
      #slot to hold a vector indicating which interval each individual is in.
      #subtract one to account for 0-indexing of C++
      # basis_out <- findInterval(x = x, vec = knots) - 1
    } else{
      basis_out <- splines2::ibs(x,knots=knots[-1], degree = 0,
                     Boundary.knots = c(knots[1],1e305), intercept = TRUE)
    }

  } else if(tolower(hazard) %in% c("royston-parmar","rp")){
    #for rp we generate basis on log scale, by transforming knots and data
    knots_log <- log(knots)
    if(any(is.infinite(knots_log) | is.na(knots_log))){
      stop("For royston-parmar model, all knots must be positive.")
    }
    temp_log <- log(x)
    temp_log[is.infinite(temp_log)] <- NA
    if(deriv){
      # basis_out <- splines2::naturalSpline(x = temp_log,
      #                knots = knots_log[-c(1,length(knots_log))],
      #                Boundary.knots = knots_log[c(1,length(knots_log))],
      #                intercept = TRUE,derivs=1)
      basis_out <- ns_d(x = temp_log,knots = knots_log[-c(1,length(knots_log))],
                    Boundary.knots = knots_log[c(1,length(knots_log))],intercept = TRUE)
      #can't set this to 0, because it is then logged and that causes a mess
      #even when it multiplies with delta1*delta2 and would otherwise be 0
      basis_out[is.na(basis_out)] <- 1
    } else{
      # basis_out <- splines2::naturalSpline(x = temp_log,
      #                  knots = knots_log[-c(1,length(knots_log))],
      #                  Boundary.knots = knots_log[c(1,length(knots_log))],
      #                  intercept = TRUE)
      basis_out <- splines::ns(x = temp_log,knots = knots_log[-c(1,length(knots_log))],
                    Boundary.knots = knots_log[c(1,length(knots_log))],intercept = TRUE)
      #This doesn't cause a problem for illness-death model
      #because the changed rows are zeroed out of the likelihood by deltas
      basis_out[is.na(basis_out)] <- 0
    }
  } else {return(NULL)}

  return(basis_out)
}


#' Get Starting Parameter Values for Univariate Model
#'
#' A function to generate principled starting values for optimization, based on
#'   model specifications.
#'
#' @inheritParams nll_uni_func
#' @inheritParams get_default_knots
#' @inheritParams get_basis
#' @param sparse_start Boolean indicating whether to set all regression parameters
#'   to 0 if \code{TRUE}, or to pre-estimate them using univariate models if \code{FALSE}.
#'
#' @return A vector of starting parameter values.
#' @importFrom pracma numderiv numdiff
#' @export
get_start_uni <- function(y, delta, yL, anyLT, Xmat, knots, basis,
                          hazard, sparse_start=FALSE){
  # browser()
  p <- if(!is.null(Xmat)) ncol(Xmat) else 0
  n <- length(y)

  #starting formula (left truncation not supported by survreg)
  form_temp <- survival::Surv(y,delta) ~ 1
  #change righthand side to include Xmat if there are covariates
  #and sparse_start not requested
  if(p > 0 & !sparse_start){
    form_temp <- stats::update.formula(form_temp, .~ Xmat)
  }

  #now, how we generate start values depends on baseline hazard
  #for weibull, fit weibull model built into survival (ignoring left truncation)
  if(tolower(hazard) %in% c("weibull","wb")){
    fit_survreg <- survival::survreg(form_temp, dist="weibull")
    alpha <- 1/fit_survreg$scale
    logkappa <- -alpha * stats::coef(fit_survreg)[1]
    names(logkappa) <- NULL
    beta <-if(sparse_start) numeric(p) else -stats::coef(fit_survreg)[-1] * alpha
    if(length(beta) > 0){
      names(beta) <- if(!is.null(colnames(Xmat))) colnames(Xmat) else NULL
    }
    return(c(lkappa=logkappa,lalpha=log(alpha),beta))
  }
  #all others are basis methods, so grab p0
  p0 <- ncol(basis)

  if(tolower(hazard) %in% c("piecewise","pw")){
    #for now, just start at the estimates for a non-piecewise exponential model
    fit_exp <- survival::survreg(form_temp, dist="exponential")
    phi <- rep(-stats::coef(fit_exp)[1],p0)
    beta <- stats::coef(fit_exp)[-1]
  } else{
    #all other starting values derived from cox model results
    #change lefthand side to account for left truncation if necessary
    if(anyLT){
      form_temp <- stats::update.formula(form_temp, survival::Surv(time = yL,time2 = y,event = delta) ~ .)
    }

    fit_coxph <- survival::coxph(form_temp)
    H0_fit <- survival::basehaz(fit_coxph, centered = F)
    beta <- if(sparse_start) numeric(p) else stats::coef(fit_coxph)
    if(tolower(hazard) %in% c("bspline", "bs")){
      #adapt an approach by cathy lee: generate grid points from which to
      #regress bspline basis onto smoothed Cox hazard
      yvals <- seq(min(y), max(y), length=500) ## get plenty of y-values
      yvals_basis <- stats::predict(basis, yvals)
      #generate smoothed baseline hazard from Cox model fit
      H0_fit_interpolate <- stats::smooth.spline(H0_fit$time, H0_fit$hazard,
                             df = length(knots)+3+1) #same df as specified model
      h0_fit_interpolate <- stats::predict(H0_fit_interpolate,x = yvals,deriv = 1)
      if(any(h0_fit_interpolate$y <= 0)){ #lm.fit can't handle log(0)=-Inf
        #replace negative values with smallest positive observed value.
        pos_min <- min(h0_fit_interpolate$y[h0_fit_interpolate$y>0])
        if(length(pos_min)==0){stop("approximate hazard to generate start values is negative! Manually enter start values.")}
        h0_fit_interpolate$y <- pmax(h0_fit_interpolate$y,pos_min)
      }
      #regress our bspline basis on the smoothed (log) baseline hazard to estimate phi
      phi <- stats::lm.fit(x = yvals_basis, y = log(h0_fit_interpolate$y))$coef

      #Previous approaches:
      # #using a fitted spline on H0
      # H0_fit_interpolate <- stats::splinefun(H0_fit$time, H0_fit$hazard, method="hyman") ## Get lin interpolated function
      # h0_fit_interpolate <- predict(H0_fit_interpolate,x = yvals,deriv = 1)
      # log_h0_fit_smooth <- log(H0_fit_interpolate(yvals,deriv=1))
      ## Cathy's approach, approximating H0 and then smoothing h0
      # H0_fit_interpolate <- stats::approxfun(H0_fit$time, H0_fit$hazard, rule = 2) ## Get lin interpolated function
      # h0_fit_interpolate <- pracma::numdiff(H0_fit_interpolate, yvals) ## estimate h0 using numerical differentiation
      # log_h0_fit_smooth <- log(stats::loess.smooth(yvals, h0_fit_interpolate, evaluation=500)$y) ## Smooth out using loess
      # phi <- stats::lm.fit(x = yvals_basis, y = log_h0_fit_smooth)$coef
    } else if(tolower(hazard) %in% c("royston-parmar","rp")){
      #following discussion in Royston-Parmar (2002), fit log(H0) and then regress spline basis
      #generates starting estimates corresponding to weibull baseline hazard
      H0_fit <- H0_fit[H0_fit$time>0 & H0_fit$hazard>0,]
      phi <- stats::lm.fit(x = stats::predict(basis,log(H0_fit$time)),
                           y = log(H0_fit$hazard) )$coef
    } else{stop("invalid hazard.")}
  }

  #add names to start value vector
  names(phi) <- c(paste0("phi",1:p0))
  if(length(beta) > 0){
    names(beta) <- if(!is.null(colnames(Xmat))) colnames(Xmat) else NULL
  }
  return(c(phi,beta))
}



#' Fit Univariate Model
#'
#' A function to fit.
#'
#' @inheritParams nll_uni_func
#' @inheritParams get_default_knots
#' @inheritParams get_basis
#' @inheritParams FreqSurv_HReg2
#'
#' @return A fit object.
#' @import nleqslv
#' @export
get_fit_uni <- function(startVals, y, delta, yL, anyLT, Xmat,
                        basis, dbasis, basis_yL, hazard,
                        control, hessian, optim_method, extra_starts){
  best_ll <- -Inf
  output <- list(fail=TRUE)

  #loop through multiple starts!
  for(extra_start_iter in 1:(extra_starts+1)){
    if(extra_start_iter == 1){ #first time, just use the default starts
      startVals_update <- startVals
    } else{ #Perturb the start values with additive and multiplicative noise
      startVals_update <- (startVals +
          stats::rnorm(n = length(startVals),mean = 0,sd=0.7)) *
          stats::runif(n = length(startVals),min = 0.9, max = 1.1)
    }

    #loop through multiple optimization options!
    #three options for optimization approaches: nlm(), optim(), and nleqslv()
    for(meth in optim_method){
      #print(meth)
      if(tolower(meth)=="nlm"){
        fit0 <- tryCatch(stats::nlm(p=startVals_update, #print.level = 2,
                          f = nll_ngrad_uni_func,
                          y=y, delta=delta,Xmat=Xmat,hazard=hazard,
                          basis=basis,dbasis=dbasis,
                          basis_yL=basis_yL,yL=yL,anyLT=anyLT,
                          iterlim=if(!is.null(control)) control$maxit else 100,
                          hessian=hessian),
                         error=function(cnd){message(cnd);cat("\n");return(NULL)})
        if(is.null(fit0)){ next }
        if (!(fit0$code %in% c(1,2))){warning("for method ",meth,"check convergence.")}
        final_ll <- -fit0$minimum
        if(final_ll <= best_ll){next}
        best_ll <- final_ll
        final_est <- fit0$estimate
        final_grad <- -fit0$gradient
        final_nhess <- if(hessian) fit0$hessian else NA
        final_startVals <- startVals_update
        optim_details = list(optim_method=meth, extra_starts=extra_starts,
                             counts=fit0$iterations, convergence=fit0$code,
                             message=NULL)

      } else if(tolower(meth)=="nleqslv"){
        fit0 <- tryCatch(nleqslv::nleqslv(x=startVals_update,fn = ngrad_uni_func,
                                      method = "Broyden", global="dbldog",
                                      y=y, delta=delta,Xmat=Xmat,hazard=hazard,
                                      basis=basis,dbasis=dbasis,
                                      basis_yL=basis_yL,yL=yL,anyLT=anyLT,
                                      control=control, jacobian=hessian),
                         error=function(cnd){message(cnd);cat("\n");return(NULL)})
        if(is.null(fit0)){ next }
        if (!(fit0$termcd %in% c(1,2))){warning("for method ",meth,"check convergence.")}
        #if the final value of nleqslv actually causes an error, catch it and set likelihood to -Inf
        final_ll <- tryCatch(-nll_uni_func(para=fit0$x, y=y, delta=delta,Xmat=Xmat,hazard=hazard,
                                basis=basis,dbasis=dbasis,basis_yL=basis_yL,yL=yL,anyLT=anyLT),
                             error=function(cnd){message(cnd);cat("\n");return(-Inf)})
        if(is.na(final_ll)){final_ll <- -Inf}
        if(final_ll <= best_ll){next}
        best_ll <- final_ll
        final_est <- fit0$x
        final_grad <- -fit0$fvec
        final_nhess <- if(hessian) fit0$jac else NA
        final_startVals <- startVals_update
        optim_details = list(optim_method=meth, extra_starts=extra_starts,
                             counts=fit0$iter, convergence=fit0$termcd,
                             message=fit0$message)

      } else{ #use method from optim()
        fit0 <- tryCatch(stats::optim(par=startVals_update, fn=nll_uni_func, gr=ngrad_uni_func,
                          y=y, delta=delta,Xmat=Xmat,hazard=hazard,
                          basis=basis,dbasis=dbasis,basis_yL=basis_yL,yL=yL,anyLT=anyLT,
                          control=control, hessian=hessian,method = meth),
                         error=function(cnd){message(cnd);cat("\n");return(NULL)})
        if(is.null(fit0)){ next }
        if (!(fit0$convergence %in% c(0,1))){warning("for method ",meth,"check convergence.")}
        final_ll <- -fit0$value
        if(final_ll <= best_ll){next}
        best_ll <- final_ll
        final_est <- fit0$par
        final_grad <- as.vector(-ngrad_uni_func(para=final_est, y=y, delta=delta,Xmat=Xmat,hazard=hazard,
                                                basis=basis,dbasis=dbasis,basis_yL=basis_yL,yL=yL,anyLT=anyLT))
        final_nhess <- if(hessian) fit0$hessian else NA
        final_startVals <- startVals_update
        optim_details = list(optim_method=meth, extra_starts=extra_starts,
                             counts=fit0$counts, convergence=fit0$convergence,
                             message=fit0$message)
      }
    }
  }

  #if any of the methods worked, then set the output to correspond with the best method
  if(best_ll > -Inf){
    output <- list(estimate=final_est,
                   logLike=best_ll,
                   grad=final_grad,
                   nhess=final_nhess,
                   optim_details=optim_details,
                   startVals=final_startVals)
  }
  output
}

####Illness-Death####

#' Generate List of Knot Location Vectors from Event Times
#'
#' This function creates a list containing three numeric vectors of increasing integers giving the location of knots used for
#'   spline and piecewise baseline hazard specifications, corresponding with the
#'   illness-death model transition hazards. The knots are generated according to
#'   the description of \code{\link{get_default_knots}}.
#'
#' @inheritParams nll_func
#' @param p01,p02,p03 Integers indicating how many parameters the model for each
#'   transition baseline hazard should specify.
#'
#' @return A list of three increasing sequences of integers, each corresponding to
#'   the knots for the flexible model on the corresponding transition baseline hazard.
#' @export
get_default_knots_list <- function(y1,y2,delta1,delta2,p01,p02,p03,hazard,model){
  delta2_cr <- ifelse(y1<y2,0,delta2)
  knots1 <- get_default_knots(y = y1, delta = delta1,p0 = p01,hazard = hazard)
  knots2 <- get_default_knots(y = y1, delta = delta2_cr, p0 = p02, hazard=hazard)
  knots3 <- get_default_knots(y = if(tolower(model)=="semi-markov") (y2-y1)[delta1==1] else y2[delta1==1],
                              delta = delta2[delta1==1], p0 = p03, hazard=hazard)
  return(list(knots1,knots2,knots3))
}


#' Get Starting Parameter Values
#'
#' A function to generate principled starting values for optimization of illness-death model, based on
#'   model specifications. Approach is to generate values for each transition using \code{\link{get_start_uni}}.
#'   For frailty-based illness-death models, a generic start value of 0.5 is chosen for frailty log-variance parameter.
#'
#' @inheritParams nll_func
#' @inheritParams FreqID_HReg2
#' @param sparse_start Boolean indicating whether to set all regression parameters
#'   to 0 if \code{TRUE}, or to pre-estimate them using univariate models if \code{FALSE}.
#'
#' @return A vector of starting parameter values.
#' @export
get_start <- function(y1,y2,delta1,delta2,yL,anyLT,
                      Xmat1,Xmat2,Xmat3, knots_list,
                      basis1,basis2,basis3,
                      hazard,frailty,model,sparse_start=FALSE){
  # browser()
  p01 <- if(tolower(hazard) %in% c("weibull","wb")) 2 else ncol(basis1)
  p02 <- if(tolower(hazard) %in% c("weibull","wb")) 2 else ncol(basis2)
  p03 <- if(tolower(hazard) %in% c("weibull","wb")) 2 else ncol(basis3)
  #start values for first transition hazard
  start1 <- get_start_uni(y = y1, delta = delta1, yL = yL, anyLT = anyLT,
                          Xmat = Xmat1, knots = knots_list[[1]], basis = basis1,
                          hazard = hazard, sparse_start=sparse_start)
  #start values for second transition hazard
  #define new indicator for terminal event, treating non-terminal as competing risk
  delta_cr <- ifelse(y1 < y2, 0, delta2)
  start2 <- get_start_uni(y = y1, delta = delta_cr, yL = yL, anyLT = anyLT,
                          Xmat = Xmat2, knots = knots_list[[2]], basis = basis2,
                          hazard = hazard, sparse_start=sparse_start)
  #prepare inputs for third transition model fit
  ismarkov <- as.numeric(tolower(model)=="markov") #markov model is left-truncated
  y_sub <- if(ismarkov) y2[delta1==1] else (y2-y1)[delta1==1]
  yL_sub <- if(ismarkov) y1[delta1==1] else numeric(0)
  delta2_sub <- delta2[delta1==1]
  Xmat3_sub <- Xmat3[delta1==1,,drop=FALSE]
  #basis is only ever used for getting p0 and using relevant predict() function,
  #so no need to subset it.

  start3 <- get_start_uni(y = y_sub, delta = delta2_sub, yL = yL_sub,
                anyLT = ismarkov, Xmat = Xmat3_sub, knots = knots_list[[3]],
                basis = basis3, hazard = hazard, sparse_start=sparse_start)

  phi1 <- start1[1:p01]
  phi2 <- start2[1:p02]
  phi3 <- start3[1:p03]
  names(phi1) <- if(tolower(hazard) %in% c("weibull","wb")) c("lkappa1","lalpha1") else c(paste0("phi",1:p01,"_1"))
  names(phi2) <- if(tolower(hazard) %in% c("weibull","wb")) c("lkappa2","lalpha2") else c(paste0("phi",1:p02,"_2"))
  names(phi3) <- if(tolower(hazard) %in% c("weibull","wb")) c("lkappa3","lalpha3") else c(paste0("phi",1:p03,"_3"))
  beta1 <- start1[-(1:p01)]
  beta2 <- start2[-(1:p02)]
  beta3 <- start3[-(1:p03)]
  if(length(beta1) > 0){
    names(beta1) <- if(!is.null(colnames(Xmat1))) paste0(colnames(Xmat1),"_1") else NULL
  }
  if(length(beta2) > 0){
    names(beta2) <- if(!is.null(colnames(Xmat2))) paste0(colnames(Xmat2),"_2") else NULL
  }
  if(length(beta3) > 0){
    names(beta3) <- if(!is.null(colnames(Xmat3))) paste0(colnames(Xmat3),"_3") else NULL
  }
  startVals <- c(phi1,phi2,phi3, ltheta= if(frailty) 1 else NULL,
               beta1,beta2,beta3)

  # #Used to test royston-parmar starting values to see if they were admissible,
  # #but I think it's unnecessary now.
  # if(tolower(hazard) %in% c("royston-parmar","rp")){
  #   getout <- FALSE
  #   for(i in c(seq(0,3,0.5),seq(-0.5,-3,-0.5))){
  #     for(j in c(seq(0,3,0.5),seq(-0.5,-3,-0.5))){
  #       #we will just consider toggling the last two parameter values per hazard
  #       startVals[c(p01-1,p01+p02-1,p01+p02+p03-1)] <- startVals[c(p01-1,p01+p02-1,p01+p02+p03-1)] + i
  #       startVals[c(p01,p01+p02,p01+p02+p03)] <- startVals[c(p01,p01+p02,p01+p02+p03)] + j
  #       ll_temp <- nll_func(para=startVals,y1=y1, y2=y2, delta1=delta1, delta2=delta2,
  #                           Xmat1=Xmat1, Xmat2=Xmat2, Xmat3=Xmat3,
  #                           hazard=hazard, frailty=frailty, model=model,
  #                           basis1=basis1, basis2=basis2, basis3=basis3, basis3_y1=basis3_y1,
  #                           dbasis1=dbasis1, dbasis2=dbasis2, dbasis3=dbasis3)
  #       if(!is.nan(ll_temp) ){
  #         # print('viable royston parmar starting value found!')
  #         getout <- TRUE
  #       }
  #       if(getout){break}
  #     }
  #     if(getout){break}
  #   }
  #   if(!getout){stop("finite starting royston-parmar log likelihood value not found. Try manually inputting valid start values.")}
  # }

  return(startVals)
}


#' Get Non-Frailty Illness-Death Model Fit
#'
#' A fitting function used to estimate a non-frailty illness-death model.
#'
#' @inheritParams nll_func
#' @inheritParams FreqID_HReg2
#'
#' @param startVals_nf A vector of starting parameter values without a frailty variance,
#'   such as computed by \code{\link{get_start}}.
#'
#' @return A vector of starting parameter values.
#' @export
get_fit_nf <- function(startVals_nf,y1,y2,delta1,delta2,yL,anyLT,
                       Xmat1,Xmat2,Xmat3, knots_list,
                       basis1,basis2,basis3,basis3_y1,basis1_yL,basis2_yL,
                       dbasis1,dbasis2,dbasis3,hazard,model,control,
                       hessian,optim_method,extra_starts){
  # browser()
  #generate starting values based on the chosen form of the baseline hazard.
  p01 <- if(tolower(hazard) %in% c("weibull","wb")) 2 else ncol(basis1)
  p02 <- if(tolower(hazard) %in% c("weibull","wb")) 2 else ncol(basis2)
  p03 <- if(tolower(hazard) %in% c("weibull","wb")) 2 else ncol(basis3)
  nP <- c(ncol(Xmat1), ncol(Xmat2), ncol(Xmat3))
  nP0 <- c(p01,p02,p03)
  nP0_tot <- sum(nP0)

  #get start values from inputs (which are arranged assuming no frailty)
  start1 <- c(startVals_nf[1:p01],
              if(nP[1]>0) startVals_nf[(1+nP0_tot):(nP0_tot+nP[1])] )
  start2 <- c(startVals_nf[(1+p01):(p01+p02)],
              if(nP[2]>0) startVals_nf[(1+nP0_tot+nP[1]):(nP0_tot+nP[1]+nP[2])] )
  start3 <- c(startVals_nf[(1+p01+p02):(p01+p02+p03)],
              if(nP[3]>0) startVals_nf[(1+nP0_tot+nP[1]+nP[2]):(nP0_tot+nP[1]+nP[2]+nP[3])] )

  #prepare event indicator for second transition model fit
  delta_cr <- ifelse(y1 < y2, 0, delta2)

  #prepare inputs for third transition model fit
  ismarkov <- as.numeric(tolower(model)=="markov") #markov model is left-truncated
  y_sub <- if(ismarkov) y2[delta1==1] else (y2-y1)[delta1==1]
  yL_sub <- if(ismarkov) y1[delta1==1] else numeric(0)
  delta2_sub <- delta2[delta1==1]
  Xmat3_sub <- Xmat3[delta1==1,,drop=FALSE]
  dbasis3_sub <- dbasis3[delta1==1,,drop=FALSE]
  basis3_y1_sub <- NULL
  if(hazard %in% c("piecewise","pw")){
    #basis is already defined for either Markov or semi-Markov, so just subset
    basis3_sub <- basis3[delta1==1,,drop=FALSE]
    #for non-frailty piecewise, need to update basis1,basis2 for left truncation
    #basis1_yL and basis2_yL are not themselves used in PW nll_uni or ngrad_uni
    if(anyLT){
      basis1 <- basis1 - basis1_yL
      basis2 <- basis2 - basis2_yL
    }
  } else if(hazard %in% c("royston-parmar","rp")){
    basis3_sub <- stats::predict(basis3,log(y_sub))
    #rp model requires separate basis3 matrix for Markov left truncation
    basis3_y1_sub <- if(ismarkov) stats::predict(basis3,log(yL_sub)) else NULL
  } else if(hazard %in% c("bspline","bs")){
    n_quad <- NROW(basis1)/NROW(y1) - 1
    quad_method <- attr(x=basis1,which="quad_method")
    #under left truncation, for bspline get_fit_uni takes y-yL as y
    if(anyLT) y1 <- y1 - yL
    if(ismarkov){
      #note yL is lower bound of integral to account for left truncation
      y_quad_sub <- c(y_sub, transform_quad_points(n_quad=n_quad,a=yL_sub,b=y_sub,
                                                   quad_method=quad_method))
      y_sub <- y_sub - yL_sub
    } else{
      y_quad_sub <- c(y_sub, transform_quad_points(n_quad=n_quad,a=0,b=y_sub,
                                                   quad_method=quad_method))
    }
    basis3_sub <- stats::predict(basis3,y_quad_sub)
    attr(x=basis3_sub,which="quad_method") <- tolower(quad_method)
  }

  fit01 <- get_fit_uni(startVals=start1, y=y1, delta=delta1,
                       Xmat=Xmat1, hazard=hazard, basis=basis1, dbasis=dbasis1,
                       yL=yL, basis_yL=basis1_yL, anyLT=anyLT,
                       control=control, hessian=hessian,
                       optim_method=optim_method, extra_starts=extra_starts)
  fit02 <- get_fit_uni(startVals=start2, y=y1, delta=delta_cr,
                       Xmat=Xmat2, hazard=hazard, basis = basis2, dbasis=dbasis2,
                       yL=yL, basis_yL=basis2_yL, anyLT=anyLT,
                       control=control, hessian=hessian,
                       optim_method=optim_method, extra_starts=extra_starts)
  fit03 <- get_fit_uni(startVals=start3, y=y_sub, delta=delta2_sub,
                       Xmat=Xmat3_sub, hazard=hazard, basis=basis3_sub, dbasis=dbasis3_sub,
                       yL=yL_sub, basis_yL=basis3_y1_sub, anyLT=ismarkov,
                       control=control, hessian=hessian,
                       optim_method=optim_method, extra_starts=extra_starts)

  #if any of the three fail, scrap the whole thing!
  if(any(!is.null(fit01$fail),!is.null(fit02$fail),!is.null(fit03$fail))){
    return(list(fail=TRUE,logLike=NA))
  }

  #if needed, construct block-diagonal vcov matrix
  if(hessian){
    Finv1 <- MASS::ginv(fit01$nhess)
    Finv2 <- MASS::ginv(fit02$nhess)
    Finv3 <- MASS::ginv(fit03$nhess)
    #create block-diagonal matrix
    Finv <- rbind(
      cbind(Finv1[1:p01,1:p01],matrix(data=0,nrow=p01,ncol=p02+p03+sum(nP))),
      cbind(matrix(data=0,nrow=p02,ncol=p01),Finv2[1:p02,1:p02],matrix(data=0,nrow=p02,ncol=p03+sum(nP))),
      cbind(matrix(data=0,nrow=p03,ncol=p01+p02),Finv3[1:p03,1:p03],matrix(data=0,nrow=p03,ncol=sum(nP))),
      cbind(matrix(data=0,nrow=nP[1],ncol=sum(nP0)),Finv1[-(1:p01),-(1:p01)],matrix(data=0,nrow=nP[1],ncol=nP[2]+nP[3])),
      cbind(matrix(data=0,nrow=nP[2],ncol=sum(nP0)+nP[1]),Finv2[-(1:p02),-(1:p02)],matrix(data=0,nrow=nP[2],ncol=nP[3])),
      cbind(matrix(data=0,nrow=nP[3],ncol=sum(nP0)+nP[1]+nP[2]),Finv3[-(1:p03),-(1:p03)]))
  }

  return(list(
    estimate=c(fit01$estimate[1:p01],fit02$estimate[1:p02],fit03$estimate[1:p03],
      fit01$estimate[-(1:p01)],fit02$estimate[-(1:p02)],fit03$estimate[-(1:p03)]),
    Finv = if(hessian) Finv else NA,
    grad = c(fit01$grad[1:p01],fit02$grad[1:p02],fit03$grad[1:p03],
             fit01$grad[-(1:p01)],fit02$grad[-(1:p02)],fit03$grad[-(1:p03)]),
    logLike = sum(fit01$logLike,fit02$logLike,fit03$logLike),
    logLike_ind = c(fit01$logLike,fit02$logLike,fit03$logLike),
    optim_details = list(fit01$optim_details,fit02$optim_details,fit03$optim_details),
    startVals=startVals_nf
  ))
}




#' Get Frailty Illness-Death Model Fit
#'
#' A fitting function used to estimate a non-frailty illness-death model.
#'
#' @inheritParams nll_func
#' @inheritParams FreqID_HReg2
#'
#' @return A vector of starting parameter values.
#' @export
get_fit_frail <- function(startVals,y1,y2,delta1,delta2,yL,anyLT,
                       Xmat1,Xmat2,Xmat3, knots_list,
                       basis1,basis2,basis3,basis3_y1,basis1_yL,basis2_yL,
                       dbasis1,dbasis2,dbasis3, hazard,model,frailty,
                       control,hessian,optim_method,extra_starts){
  # browser()
  best_ll <- -Inf
  output <- list(fail=TRUE)

  #loop through multiple starts!
  for(extra_start_iter in 1:(extra_starts+1)){
    if(extra_start_iter == 1){ #first time, just use the default starts
      startVals_update <- startVals
    } else{ #Perturb the start values with additive and multiplicative noise
      startVals_update <- (startVals +
        stats::rnorm(n = length(startVals),mean = 0,sd=0.7)) *
        stats::runif(n = length(startVals),min = 0.9, max = 1.1)
    }

    #loop through multiple options!
    #three options for optimization approaches: nlm(), optim(), and nleqslv()
    for(meth in optim_method){
      if(tolower(meth)=="nlm"){
        fit0 <- tryCatch(stats::nlm(p=startVals_update, f=nll_ngrad_func,
                  y1=y1, y2=y2, delta1=delta1, delta2=delta2, yL=yL, anyLT=anyLT,
                  Xmat1=Xmat1, Xmat2=Xmat2, Xmat3=Xmat3,
                  hazard=hazard,frailty=frailty,model=model,
                  basis1=basis1, basis2=basis2, basis3=basis3, basis3_y1=basis3_y1,
                  basis1_yL=basis1_yL,basis2_yL=basis2_yL,
                  dbasis1=dbasis1, dbasis2=dbasis2, dbasis3=dbasis3,
                  iterlim=if(!is.null(control)) control$maxit else 100,
                  hessian=hessian),
                 error=function(cnd){message(cnd);cat("\n");return(NULL)})
        if(is.null(fit0)){ next }
        if (!(fit0$code %in% c(1,2))){warning("check convergence.")}
        final_ll <- -fit0$minimum
        if(final_ll <= best_ll){next}
        best_ll <- final_ll
        final_est <- fit0$estimate
        final_grad <- -fit0$gradient
        final_nhess <- if(hessian) fit0$hessian else NA
        final_startVals <- startVals_update
        optim_details = list(optim_method=meth, extra_starts=extra_starts,
                             counts=fit0$iterations, convergence=fit0$code,
                             message=NULL)

      } else if(tolower(meth)=="nleqslv"){
        fit0 <- tryCatch(nleqslv::nleqslv(x=startVals_update, fn=ngrad_func,
                            method="Broyden",global = "dbldog",
                            y1=y1, y2=y2, delta1=delta1, delta2=delta2, yL=yL, anyLT=anyLT,
                            Xmat1=Xmat1, Xmat2=Xmat2, Xmat3=Xmat3,
                            hazard=hazard,frailty=frailty,model=model,
                            basis1=basis1, basis2=basis2, basis3=basis3, basis3_y1=basis3_y1,
                            basis1_yL=basis1_yL,basis2_yL=basis2_yL,
                            dbasis1=dbasis1, dbasis2=dbasis2, dbasis3=dbasis3,
                            control=control, jacobian=hessian),
                         error=function(cnd){message(cnd);cat("\n");return(NULL)})
        if(is.null(fit0)){ next }
        if (!(fit0$termcd %in% c(1,2))){warning("check convergence.")}
        #if the final value of nleqslv actually causes an error, catch it and set likelihood to -Inf
        final_ll <- tryCatch(-nll_func(para=fit0$x, y1=y1, y2=y2,
                        delta1=delta1, delta2=delta2, yL=yL, anyLT=anyLT,
                        Xmat1=Xmat1, Xmat2=Xmat2, Xmat3=Xmat3,
                        hazard=hazard,frailty=frailty,model=model,
                        basis1=basis1, basis2=basis2,
                        basis3=basis3, basis3_y1=basis3_y1,
                        basis1_yL=basis1_yL,basis2_yL=basis2_yL,
                        dbasis1=dbasis1, dbasis2=dbasis2, dbasis3=dbasis3),
                       error=function(cnd){message(cnd);cat("\n");return(-Inf)})
        if(is.na(final_ll)){final_ll <- -Inf}
        if(final_ll <= best_ll){next}
        best_ll <- final_ll
        final_est <- fit0$x
        final_grad <- -fit0$fvec
        final_nhess <- if(hessian) fit0$jac else NA
        final_startVals <- startVals_update
        optim_details = list(optim_method=meth, extra_starts=extra_starts,
                             counts=fit0$iter, convergence=fit0$termcd,
                             message=fit0$message)

      } else{ #use method from optim()
        fit0 <- tryCatch(stats::optim(par=startVals_update, fn=nll_func, gr=ngrad_func,
                  y1=y1, y2=y2, delta1=delta1, delta2=delta2, yL=yL, anyLT=anyLT,
                  Xmat1=Xmat1, Xmat2=Xmat2, Xmat3=Xmat3,
                  hazard=hazard,frailty=frailty,model=model,
                  basis1=basis1, basis2=basis2, basis3=basis3, basis3_y1=basis3_y1,
                  basis1_yL=basis1_yL,basis2_yL=basis2_yL,
                  dbasis1=dbasis1, dbasis2=dbasis2, dbasis3=dbasis3,
                  control=control, hessian=hessian,method=meth),
                 error=function(cnd){message(cnd);cat("\n");return(NULL)})
        if(is.null(fit0)){ next }
        if (!(fit0$convergence %in% c(0,1))){warning("check convergence.")}
        final_ll <- -fit0$value
        if(final_ll <= best_ll){next}
        best_ll <- final_ll
        final_est <- fit0$par
        final_grad <- as.vector(-ngrad_func(para=final_est, y1=y1, y2=y2,
                            delta1=delta1, delta2=delta2, yL=yL, anyLT=anyLT,
                            Xmat1=Xmat1, Xmat2=Xmat2, Xmat3=Xmat3,
                            hazard=hazard,frailty=frailty,model=model,
                            basis1=basis1, basis2=basis2,
                            basis3=basis3, basis3_y1=basis3_y1,
                            basis1_yL=basis1_yL,basis2_yL=basis2_yL,
                            dbasis1=dbasis1, dbasis2=dbasis2, dbasis3=dbasis3))
        final_nhess <- if(hessian) fit0$hessian else NA
        final_startVals <- startVals_update
        optim_details = list(optim_method=meth, extra_starts=extra_starts,
                             counts=fit0$counts, convergence=fit0$convergence,
                             message=fit0$message)
      }
    }
  }

  #if any of the methods worked, set the output to correspond with the best method
  if(best_ll > -Inf){
    output <- list(estimate=final_est,
                   logLike=best_ll,
                   grad=final_grad,
                   nhess=final_nhess,
                   optim_details=optim_details,
                   startVals=final_startVals)
  }
  output
}




