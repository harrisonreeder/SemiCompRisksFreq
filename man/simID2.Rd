% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simID2.R
\name{simID2}
\alias{simID2}
\title{The function that simulates independent/cluster-correlated semi-competing
risks data under Markov/semi-Markov Weibull models.}
\usage{
simID2(
  id = NULL,
  x1,
  x2,
  x3,
  beta1.true,
  beta2.true,
  beta3.true,
  phi1.true = NULL,
  phi2.true = NULL,
  phi3.true = NULL,
  alpha1.true = NULL,
  alpha2.true = NULL,
  alpha3.true = NULL,
  kappa1.true = NULL,
  kappa2.true = NULL,
  kappa3.true = NULL,
  theta.true,
  SigmaV.true = NULL,
  hazard,
  knots_list,
  model = "semi-markov",
  frailty_type = "gamma",
  beta2frail.true = 1,
  beta3frail.true = 1,
  beta3tv.true = NULL,
  h3tv_degree = 3,
  h3tv_knots = NULL,
  LT_interval = c(0, 0),
  cens = c(0, 0)
)
}
\arguments{
\item{id}{A vector of cluster information for \code{n} subjects.
The cluster membership must be set to consecutive positive integers, \code{1:J}.
Required only when generating clustered data.}

\item{x1, x2, x3}{Covariate matrices with \code{n} rows.}

\item{beta1.true, beta2.true, beta3.true}{Vectors of true regression
parameter values. The length of each vector should equal
the number of columns in the corresponding covariate matrix.}

\item{phi1.true, phi2.true, phi3.true}{Vectors of true baseline parameter values.
For weibull, each should be a vector with c(log-kappa, log-alpha).}

\item{alpha1.true, alpha2.true, alpha3.true, kappa1.true, kappa2.true, kappa3.true}{Scalar true baseline parameter values for weibull specification (included for backwards-compatibility).
Used if baseline is Weibull and \code{phi1.true}, \code{phi2.true}, or \code{phi3.true} are null.
Note these parameters are exponentiated, and thus are expected to be positive.
By comparison, Weibull model fitting is done using log-transformed versions of these parameters.}

\item{theta.true}{True value for \eqn{\theta}.}

\item{SigmaV.true}{True value for covariance matrix of MVN
cluster-level random effects. Required only when generating clustered data.
Should be a numeric \eqn{J\times J} matrix.}

\item{hazard}{String (not case sensitive) specifying the form of the baseline hazard.
Options are \code{"weibull"} for Weibull,
\code{"piecewise"} for piecewise constant on the hazard scale,
\code{"bspline"} for cubic B-spline on the log-hazard scale,
and \code{"royston-parmar"} for restricted cubic spline on the log-cumulative hazard scale.
Aliases for these are \code{"wb"}, \code{"pw"}, \code{"bs"}, and \code{"rp"} respectively.}

\item{knots_list}{Used for hazard specifications besides Weibull, a
list of three increasing sequences of integers, each corresponding to
the knots for the flexible model on the corresponding transition baseline hazard.
If \code{NULL}, will be created by \code{\link{get_default_knots_list}}
according to the number of parameters specified by \code{nP0}.}

\item{model}{String (not case sensitive) specifying the transition assumption: either \code{"semi-Markov"}}

\item{frailty_type}{string denoting "gamma" for gamma-distributed frailty
with variance \code{theta}, or "lognormal" for lognormal distributed
frailty with log-frailty variance \code{theta}}

\item{beta2frail.true, beta3frail.true}{scalar for the coefficient
of the shared frailty in the \eqn{h_2} and \eqn{h_3} submodels.}

\item{beta3tv.true}{Vectors of true regression parameter values
for direct effects of \eqn{t_1} on the \eqn{h_3} submodel.}

\item{h3tv_degree}{either the string "cs" indicating restricted
cubic spline, or an integer for degree of time-varying hazard/odds ratio
B-spline basis. (0 is piecewise constant)}

\item{h3tv_knots}{if a direct effect of \eqn{t_1} on the \eqn{h_3} submodel
is specified in terms of a spline,
this can be used to specify the knots used in the spline basis definition.
By default quantiles of the observed non-terminal events are used.}

\item{LT_interval}{A numeric vector of two elements. The left truncation
times are generated from Uniform(\eqn{LT_interval[1]}, \eqn{LT_interval[2]}).
Setting to \code{c(0,0)} corresponds with no left-truncation.}

\item{cens}{A numeric vector of two elements. The right censoring
times are generated from Uniform(\eqn{cens[1]}, \eqn{cens[2]}).
Setting to \code{c(0,0)} corresponds with no independent right censoring.}
}
\value{
returns a data.frame containing semi-competing risks
outcomes from \code{n} subjects, with columns as follows: \cr
\describe{
\item{y1}{a vector of \code{n} times for the non-terminal event}
\item{delta1}{a vector of \code{n} censoring indicators for the non-terminal event time (1=event occurred, 0=censored)}
\item{y2}{a vector of \code{n} times for the terminal event}
\item{delta2}{a vector of \code{n} censoring indicators for the terminal event time (1=event occurred, 0=censored)}
\item{yL}{a vector of \code{n} times of left censoring}
\item{gamma.true}{a vector of true frailty values}
\item{x3tv}{a matrix of basis functions corresponding to the direct
time-varying effect of \eqn{T_1} on \eqn{h_3}, if applicable.}
\item{id}{a vector of cluster membership labels}
\item{Vmat}{an \eqn{n \times 3} matrix of true cluster-specific random effects}
}
\cr
Additionally, if a direct time-varying effect of \eqn{t_1} on \eqn{h_3} is
specified, the returned data frame is given the following attributes:
\describe{
\item{p3tv}{total number of parameters corresponding to effect}
\item{h3tv_degree}{degree of spline effect, as specified by user}
\item{h3tv_knots}{vector of knots corresponding with effect}
}
}
\description{
The function that simulates independent/cluster-correlated semi-competing
risks data under Markov/semi-Markov Weibull models.
}
\examples{
n <- 5000
set.seed(1234)
x_sim <- matrix(rnorm(3*n),ncol=3)
colnames(x_sim) <- c("x1","x2","x3")

##Example 1: semi-markov weibull illness-death model
# with piecewise constant effect of t1 on h3 hazard.

#h3 knots for piecewise constant effect of t1 on h3
h3_knots_temp <- c(0,3,8,15.5,Inf)

simDat <- simID2(x1=x_sim,x2=x_sim,x3=x_sim,
                 beta1.true = c(0.25,0.6,-0.3),
                 beta2.true = c(0.4,0.75,-0.4),
                 beta3.true = c(0.7,0.9,-0.9),
                 alpha1.true = exp(-0.6),
                 alpha2.true = exp(-0.3),
                 alpha3.true = exp(-0.4),
                 kappa1.true = exp(-1.2),
                 kappa2.true = exp(-2.9),
                 kappa3.true = exp(-3.2),
                 hazard = "Weibull",model = "semi-Markov",
                 frailty_type = "gamma", theta.true = 1,
                 h3tv_degree = 0,
                 h3tv_knots = h3_knots_temp, beta3tv.true = c(1.5,0,-1.5),
                 LT_interval=c(0,0), cens = c(60,60))

#fitting the corresponding 'correctly specified' illness-death model
fit_WB <- FreqID_HReg2(Formula(y1 + delta1 | y2 + delta2 ~
         x1 + x2 + x3 | x1 + x2 + x3 | x1 + x2 + x3 + h3tv1 + h3tv2 + h3tv3),
             data = cbind(simDat,x_sim), hazard = "Weibull", frailty=TRUE,
             model = "semi-Markov")
fit_WB


##Example 2: Markov illness-death model, piecewise constant baseline hazards


knots_pw_list_true <- list(c(0,5,15,20), c(0,5,15,20), c(0,5,10))
phi1_true <- log(c(0.035,0.025,0.020,0.025))
phi2_true <- log(c(0.005,0.010,0.025,0.018))
phi3_true <- log(c(0.008,0.015,0.024))

simDat_pw <- simID2(x1=x_sim,x2=x_sim,x3=x_sim,
                    beta1.true = c(0.25,0.6,-0.3),
                    beta2.true = c(0.4,0.75,-0.4),
                    beta3.true = c(0.7,0.9,-0.9),
                    phi1.true = phi1_true,
                    phi2.true = phi2_true,
                    phi3.true = phi3_true,
                    hazard = "Piecewise",model = "Markov",
                    knots_list = knots_pw_list_true,
                    frailty_type = "gamma",theta.true = 1,
                    LT_interval=c(0,0), cens = c(60,60))

#fitting the corresponding 'correctly specified' illness-death model
fit_PW <- FreqID_HReg2(Formula(y1 + delta1 | y2 + delta2 ~
                                x1 + x2 + x3 | x1 + x2 + x3 | x1 + x2 + x3),
                       data = cbind(simDat,x_sim), hazard = "Piecewise",
                       knots_list = knots_pw_list_true,
                       model = "Markov", frailty=TRUE)
fit_PW

}
